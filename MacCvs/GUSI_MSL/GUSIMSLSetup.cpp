/**************** BEGIN GUSI CONFIGURATION ****************************
 *
 * GUSI Configuration section generated by GUSI Configurator
 * last modified: Tue Feb  8 13:55:13 2000
 *
 * This section will be overwritten by the next run of Configurator.
 */

#include <GUSIInternal.h>
#include <GUSIOpenTransport.h>
#include <GUSIConfig.h>
#include <GUSITimer.h>
#include <GUSISocket.h>
#include <GUSIDevice.h>
#include <GUSIDescriptor.h>
#include <sys/cdefs.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <console.h>
#include <stdio.h>
#include "GUSIMSLSetup.h"
#include <TextUtils.h>
#include <CodeFragments.h>
#include <Resources.h>

extern "C" void SIOUXHandleOneEvent(EventRecord *userevent);

static void _dispatchevent(EventRecord *userevent);
static bool _dispatchspin(bool wait);
static bool _dispatchexec(const FSSpec * file);
static GusiMSLWriteConsole sWriteConsole = 0L;
static GusiMSLWriteConsole sErrConsole = 0L;
static GusiMSLWriteConsole sInConsole = 0L;
static GusiMSLHandleEvent sHandleEvent = 0L;

/* Declarations of Socket Factories */

__BEGIN_DECLS
void GUSIwithInetSockets();
void GUSIwithLocalSockets();
void GUSIwithMTInetSockets();
void GUSIwithMTTcpSockets();
void GUSIwithMTUdpSockets();
void GUSIwithOTInetSockets();
void GUSIwithOTTcpSockets();
void GUSIwithOTUdpSockets();
void GUSIwithPPCSockets();
void GUSISetupFactories();
__END_DECLS

/* Configure Socket Factories */

void GUSISetupFactories()
{
#ifdef GUSISetupFactories_BeginHook
	GUSISetupFactories_BeginHook
#endif
	GUSIwithInetSockets();
#ifdef GUSISetupFactories_EndHook
	GUSISetupFactories_EndHook
#endif
}

/* Declarations of File Devices */

__BEGIN_DECLS
void GUSIwithDConSockets();
void GUSIwithNullSockets();
void GUSISetupDevices();
__END_DECLS

/* Configure File Devices */

void GUSISetupDevices()
{
#ifdef GUSISetupDevices_BeginHook
	GUSISetupDevices_BeginHook
#endif
	GUSIwithNullSockets();
#ifdef GUSISetupDevices_EndHook
	GUSISetupDevices_EndHook
#endif
}

#ifndef __cplusplus
#error GUSISetupConfig() needs to be written in C++
#endif

GUSIConfiguration::FileSuffix	sSuffices[] = {
	"", '????', '????'
};

extern "C" void GUSISetupConfig()
{
	GUSIConfiguration * config =
		GUSIConfiguration::CreateInstance(GUSIConfiguration::kNoResource);

	config->ConfigureDefaultTypeCreator('TEXT', 'CWIE');
	config->ConfigureSuffices(
		sizeof(sSuffices)/sizeof(GUSIConfiguration::FileSuffix)-1, sSuffices);
	config->ConfigureAutoInitGraf(false);
	config->ConfigureAutoSpin(false);
	config->ConfigureHandleAppleEvents(false);
	config->ConfigureSharedOpen(true); // ssh

	if(sHandleEvent != 0L)
	{
		GUSISpinFn		spinFn = _dispatchspin;
		GUSIExecFn		execFn = _dispatchexec;
		GUSIHook		spinHook = (GUSIHook) spinFn;
		GUSIHook		execHook = (GUSIHook) execFn;
		GUSISetHook(GUSI_SpinHook, spinHook);
		GUSISetHook(GUSI_ExecHook, execHook);

		GUSIEventFn		eventFn = _dispatchevent;
		GUSIHook		eventHook = (GUSIHook) eventFn;
		GUSISetHook(GUSI_EventHook + nullEvent, eventHook);
		GUSISetHook(GUSI_EventHook + mouseDown, eventHook);
		GUSISetHook(GUSI_EventHook + mouseUp, eventHook);
		GUSISetHook(GUSI_EventHook + keyDown, eventHook);
		GUSISetHook(GUSI_EventHook + keyUp, eventHook);
		GUSISetHook(GUSI_EventHook + updateEvt, eventHook);
		GUSISetHook(GUSI_EventHook + diskEvt, eventHook);
		GUSISetHook(GUSI_EventHook + activateEvt, eventHook);
		GUSISetHook(GUSI_EventHook + osEvt, eventHook);
	}
}

/**************** END GUSI CONFIGURATION *************************/

bool GUSIOTFactory::Initialize()
{
	// because we have so many GUSI (MacCvs, cvs, lsh, python) we don't
	// want to initialize OpenTransport many times, this is causing troubles
	// especially on OSX
	if (!sOK)
	{
		//sOK = !InitOpenTransport();
		sOK = true;
	}
	
	return sOK;
}


/* GUSI 2.1.5 */
void GUSIProcess::Yield(GUSIYieldMode wait)
{
	if (wait == kGUSIBlock) {
		fWillSleep = true;
		if (fReadyThreads > 1 || fDontSleep) {
			GUSI_SMESSAGE("Don't Sleep\n");
			wait = kGUSIYield;
		}
	}
	if (fExistingThreads < 2) // Single threaded process skips sleep only once
		fDontSleep = false;
	if (wait == kGUSIYield && LMGetTicks() - fResumeTicks < 1) {
		fWillSleep 		= false;
		return;
	}
	if (gGUSISpinHook) {
		gGUSISpinHook(wait == kGUSIBlock);
	} else {
		GUSI_SMESSAGE("Suspend\n");
		GUSIHandleNextEvent(wait == kGUSIBlock ? 60 : 0);
		GUSI_SMESSAGE("Resume\n");
	} 
	if (fExistingThreads < 2) 		// Single threaded process skips sleep only once
		fDontSleep = false;
	fWillSleep 		= false;
	fResumeTicks 	= LMGetTicks();
	if (fClosing)
		fClosing->CheckClose();
}

/*
 * default GUSIContext::Yield has 12 ticks to remain in same state
 * we use 0.
 */

bool GUSIContext::Yield(GUSIYieldMode wait)
{
	if (wait == kGUSIYield && LMGetTicks() - sCurrentContext->fEntryTicks < 0)
		return false;	

	bool			mainThread	= sCurrentContext->fThreadID == kApplicationThreadID;
	bool 			block		= wait == kGUSIBlock && !mainThread;
	GUSIProcess	*	process 	= GUSIProcess::Instance();
	bool 			interrupt 	= false;
	
	do {
		if (mainThread)
			process->Yield(wait);
	
		if (interrupt = Raise())
			goto done;
				
		if (sHasThreading) {
			if (block)
				SetThreadState(kCurrentThreadID, kStoppedThreadState, kNoThreadID);
			else
				YieldToAnyThread();
		}
	} while (wait == kGUSIBlock && !sCurrentContext->fWakeup);
done:
	sCurrentContext->fWakeup = false;
	
	return interrupt;
}

GusiMSLWriteConsole GusiMSLSetWriteConsole(GusiMSLWriteConsole hook)
{
	GusiMSLWriteConsole oldhook = sWriteConsole;
	sWriteConsole = hook;
	return oldhook;
}

GusiMSLWriteConsole GusiMSLSetErrConsole(GusiMSLWriteConsole hook)
{
	GusiMSLWriteConsole oldhook = sErrConsole;
	sErrConsole = hook;
	return oldhook;
}

GusiMSLWriteConsole GusiMSLSetInConsole(GusiMSLWriteConsole hook)
{
	GusiMSLWriteConsole oldhook = sInConsole;
	sInConsole = hook;
	return oldhook;
}

GusiMSLHandleEvent GusiMSLSetHandleEvent(GusiMSLHandleEvent hook)
{
	GusiMSLHandleEvent oldhook = sHandleEvent;
	sHandleEvent = hook;
	return oldhook;
}

// the console stubs use our Log Window
short InstallConsole(short)
{
	return 0;
}

void RemoveConsole(void)
{
}

long WriteCharsToConsole(char *buffer, long n)
{
	if(sWriteConsole != 0L)
		return sWriteConsole(buffer, n);

	return 0;
}


long ReadCharsFromConsole(char *buffer, long n)
{
	if(sInConsole != 0L)
		return sInConsole(buffer, n);
	return 0;
}

extern char *__ttyname(long fildes)
{
	/* all streams have the same name */
	static char *__devicename = "null device";

	if (fildes >= 0 && fildes <= 2)
		return (__devicename);

	return (0L);
}

static void _dispatchevent(EventRecord *userevent)
{
	if(sHandleEvent != 0L)
	{
		sHandleEvent(userevent);
	}
	return;
}

static bool _dispatchspin(bool)
{
	_dispatchevent (0);

	return true;
}

static bool _dispatchexec(const FSSpec * file)
{
	// all file is an executable : this not good but GUSI would return
	// EACCESS on chmod(a+x);
	return true;
}

extern "C" void SIOUXHandleOneEvent(EventRecord *userevent)
{
	_dispatchevent(userevent);
}

// \section{Definition of [[GUSISIOUXSocket]]}                             
//                                                                         
// A [[GUSISIOUXSocket]] is another singleton class: There is only one SIOUX
// console per application.                                                
//                                                                         
//                                                                         
// <Declaration of class [[GUSISIOUXSocket]]>=                             
class GUSISIOUXSocket : public GUSISocket {
public:
	~GUSISIOUXSocket();
	
	// Some member functions are fairly trivial wrappers.                      
 //                                                                         
 // <Overridden member functions for class [[GUSISIOUXSocket]]>=            
 ssize_t	read(const GUSIScatterer & buffer);
 // <Overridden member functions for class [[GUSISIOUXSocket]]>=            
 ssize_t write(const GUSIGatherer & buffer);
 // <Overridden member functions for class [[GUSISIOUXSocket]]>=            
 virtual int	ioctl(unsigned int request, va_list arg);
 // Since we know we're running on a pseudodevice, we can pass on that fact.
 //                                                                         
 // <Overridden member functions for class [[GUSISIOUXSocket]]>=            
 virtual int	fstat(struct stat * buf);
 // And we also know we're a TTY.                                           
 //                                                                         
 // <Overridden member functions for class [[GUSISIOUXSocket]]>=            
 virtual int	isatty();
 // [[select]] requires a walk of the event queue.                          
 //                                                                         
 // <Overridden member functions for class [[GUSISIOUXSocket]]>=            
 bool select(bool * canRead, bool * canWrite, bool *);

	static GUSISIOUXSocket *	Instance(bool isStderr);
private:	
	GUSISIOUXSocket(bool isStderr);
	
	bool m_isStderr;
};
// \section{Definition of [[GUSISIOUXDevice]]}                             
//                                                                         
// A [[GUSISIOUXDevice]] is a singleton class supporting the standard [[open]]
// operation.                                                              
//                                                                         
// <Declaration of class [[GUSISIOUXDevice]]>=                             
class GUSISIOUXDevice : public GUSIDevice {
public:
	static GUSISIOUXDevice *	Instance();

	// [[GUSISIOUXDevice]] is prepared to handle an [[open]] on a limited set of names.
 //                                                                         
 // <Overridden member functions for class [[GUSISIOUXDevice]]>=            
 virtual bool Want(GUSIFileToken & file);
 // [[open]] returns the sole instance of [[GUSISIOUXSocket]].              
 //                                                                         
 // <Overridden member functions for class [[GUSISIOUXDevice]]>=            
 virtual GUSISocket * open(GUSIFileToken &, int flags);
private:
	GUSISIOUXDevice() 								{}
	
	static GUSISIOUXDevice *	sInstance;
};
// \section{Implementation of [[GUSISIOUXSocket]]}                         
//                                                                         
// A [[GUSISIOUXSocket]] is a dataless wrapper for the SIOUX               
// library. To protect the sole instance from ever being deleted           
// again, we artificially raise its reference count.                       
//                                                                         
// <Member functions for class [[GUSISIOUXSocket]]>=                       

GUSISIOUXSocket * GUSISIOUXSocket::Instance(bool isStderr)
{
	return new GUSISIOUXSocket(isStderr);
}
// On construction, we make sure to install the SIOUX event handler for all
// relevant elements.                                                      
//                                                                         
// <Member functions for class [[GUSISIOUXSocket]]>=                       
// This declaration lies about the return type
extern "C" void SIOUXHandleOneEvent(EventRecord *userevent);

GUSISIOUXSocket::GUSISIOUXSocket(bool isStderr) : m_isStderr(isStderr)
{
	InstallConsole(0);
	GUSISetHook(GUSI_EventHook+nullEvent, 	(GUSIHook)SIOUXHandleOneEvent);
	GUSISetHook(GUSI_EventHook+mouseDown, 	(GUSIHook)SIOUXHandleOneEvent);
	GUSISetHook(GUSI_EventHook+mouseUp, 	(GUSIHook)SIOUXHandleOneEvent);
	GUSISetHook(GUSI_EventHook+updateEvt, 	(GUSIHook)SIOUXHandleOneEvent);
	GUSISetHook(GUSI_EventHook+diskEvt, 	(GUSIHook)SIOUXHandleOneEvent);
	GUSISetHook(GUSI_EventHook+activateEvt, (GUSIHook)SIOUXHandleOneEvent);
	GUSISetHook(GUSI_EventHook+osEvt, 		(GUSIHook)SIOUXHandleOneEvent);
}
GUSISIOUXSocket::~GUSISIOUXSocket()
{
	RemoveConsole();
}
// <Member functions for class [[GUSISIOUXSocket]]>=                       
ssize_t GUSISIOUXSocket::read(const GUSIScatterer & buffer)
{
	GUSIStdioFlush();
	return buffer.SetLength(
		ReadCharsFromConsole((char *) buffer.Buffer(), (int)buffer.Length()));
}
// <Member functions for class [[GUSISIOUXSocket]]>=                       
ssize_t GUSISIOUXSocket::write(const GUSIGatherer & buffer)
{
	if(m_isStderr)
	{
		if(sErrConsole != 0L)
			return sErrConsole((char *) buffer.Buffer(), (int)buffer.Length());
	}
	else
	{
		if(sWriteConsole != 0L)
			return sWriteConsole((char *) buffer.Buffer(), (int)buffer.Length());
	}
	return WriteCharsToConsole((char *) buffer.Buffer(), (int)buffer.Length());
}
// <Member functions for class [[GUSISIOUXSocket]]>=                       
int GUSISIOUXSocket::ioctl(unsigned int request, va_list)
{
	switch (request)	{
	case FIOINTERACTIVE:
		return 0;
	default:
		return GUSISetPosixError(EOPNOTSUPP);
	}
}
// <Member functions for class [[GUSISIOUXSocket]]>=                       
int	GUSISIOUXSocket::fstat(struct stat * buf)
{
	GUSISocket::fstat(buf);
	buf->st_mode =	S_IFCHR | 0666;
	
	return 0;
}
// <Member functions for class [[GUSISIOUXSocket]]>=                       
int GUSISIOUXSocket::isatty()
{ 
	return 1;
}
// <Member functions for class [[GUSISIOUXSocket]]>=                       
static bool input_pending()
{
#if !TARGET_API_MAC_CARBON
	QHdrPtr eventQueue = LMGetEventQueue();
	EvQElPtr element = (EvQElPtr)eventQueue->qHead;
	
	// now, count the number of pending keyDown events.
	while (element != nil) {
		if (element->evtQWhat == keyDown || element->evtQWhat == autoKey)
			return true;
		element = (EvQElPtr)element->qLink;
	}
	
	return false;
#else
	return CheckEventQueueForUserCancel() != 0;
#endif
}

bool GUSISIOUXSocket::select(bool * canRead, bool * canWrite, bool *)
{
	bool cond = false;
	if (canRead)
		if (*canRead = input_pending())
			cond = true;
	if (canWrite)
		cond = *canWrite = true;
		
	return cond;
}
// \section{Implementation of [[GUSISIOUXDevice]]}                         
//                                                                         
// [[GUSISIOUXDevice]] is a singleton class.                               
//                                                                         
// <Member functions for class [[GUSISIOUXDevice]]>=                       
GUSISIOUXDevice * GUSISIOUXDevice::sInstance;
// <Member functions for class [[GUSISIOUXDevice]]>=                       
GUSISIOUXDevice * GUSISIOUXDevice::Instance()
{
	if (!sInstance)
		sInstance = new GUSISIOUXDevice();
	return sInstance;
}
// <Member functions for class [[GUSISIOUXDevice]]>=                       
bool GUSISIOUXDevice::Want(GUSIFileToken & file)
{
	switch (file.WhichRequest()) {
	case GUSIFileToken::kWillOpen:
		return file.IsDevice() && (file.StrStdStream(file.Path()) > -1);
	default:
		return false;
	}
}
// <Member functions for class [[GUSISIOUXDevice]]>=                       
GUSISocket * GUSISIOUXDevice::open(GUSIFileToken &, int)
{
	return GUSISIOUXSocket::Instance(false);
}
// A SIOUX application connects to the three standard descriptors on startup.
//                                                                         
// <SIOUX implementation of [[GUSISetupConsoleDescriptors]]>=              
void GUSISetupConsoleDescriptors()
{
	GUSIDescriptorTable * table = GUSIDescriptorTable::Instance();
	
	table->InstallSocket(GUSISIOUXSocket::Instance(false));
	table->InstallSocket(GUSISIOUXSocket::Instance(false));
	table->InstallSocket(GUSISIOUXSocket::Instance(true));
}

// the MSL at exit seems to barf on us because we ask from
// MacCvs to GUSI to close all the file descriptors before
// we quit
#if 0
extern "C" void __stdio_atexit(void)
{
}
#endif

int __no_msl_lf_convert = 0;

// overide optionally the CR/LF conversion
extern "C"
{
	void __convert_from_newlines(unsigned char * buf, size_t * n);
	void __convert_to_newlines(unsigned char * buf, size_t * n);
}

void __convert_from_newlines(unsigned char * buf, size_t * n)    /*- mm 970210 -*/
{                                                                /*- mm 970210 -*/
	if(__no_msl_lf_convert) /* CVSGUI */
		return;
	unsigned char *	p = buf;                                     /*- mm 970210 -*/
	size_t			i = *n;                                      /*- mm 970210 -*/
	while (i--)                                                  /*- mm 970210 -*/
	{                                                            /*- mm 970210 -*/
		if (*p=='\r') *p = '\n';                                 /*- mm 970210 -*/
		else if (*p=='\n') *p = '\r';                            /*- mm 970210 -*/
		p++;                                                     /*- mm 970210 -*/
	}                                                            /*- mm 970210 -*/
}

void __convert_to_newlines(unsigned char * buf, size_t * n)      /*- mm 970210 -*/
{                                                                /*- mm 970210 -*/
	if(__no_msl_lf_convert) /* CVSGUI */
		return;
	unsigned char *	p = buf;                                     /*- mm 970210 -*/
	size_t			i = *n;                                      /*- mm 970210 -*/
	while (i--)                                                  /*- mm 970210 -*/
	{                                                            /*- mm 970210 -*/
		if (*p=='\n') *p = '\r';                                 /*- mm 970210 -*/
		else if (*p=='\r') *p = '\n';                            /*- mm 970210 -*/
		p++;                                                     /*- mm 970210 -*/
	}                                                            /*- mm 970210 -*/
}

#if 0
// from Metrowerks runtime
extern pascal OSErr __initialize(CFragConnectionID connID);
extern pascal void __terminate(void);

// for cvs
pascal OSErr __gusimsl_initialize(const CFragInitBlock * theInitBlock);
pascal void __gusimsl_terminate(void);

__declspec(dllexport) extern short gRealAppResID;

short gRealAppResID = -1;

pascal OSErr __gusimsl_initialize(const CFragInitBlock * theInitBlock)
{
	OSErr result = noErr;

	gRealAppResID = ::CurResFile();
	
	return __initialize(theInitBlock->connectionID);
}

pascal void __gusimsl_terminate(void)
{
	__terminate();
}
#endif

#define qOverideAlloc 0
	// attempt to intercept all allocations
#define qExtensiveAllocVerif 1 && qCvsDebug
	// Verify a bunch of things, but it's very slow

#if qOverideAlloc
#include <CodeFragments.h>
#include <new>
#include <stdlib.h>

#if TARGET_API_MAC_CARBON
#define INTERFACELIB "\pCarbonLib"
#else
#define INTERFACELIB "\pInterfaceLib"
#endif

#if qCvsDebug || qExtensiveAllocVerif
#define SP_CHECK(cond) do { if(!(cond)) DebugStr("\p" #cond); } while(0)
#else
#define SP_CHECK(cond)
#endif

extern "C"
{
	typedef Ptr (*NewPtrTypeProc)(Size byteCount);
	typedef void (*DisposePtrTypeProc)(Ptr);
}

static void * OSAllocateMem(size_t count)
{
	static NewPtrTypeProc newPtr = NULL;
	
	if(newPtr == 0L)
	{
		CFragConnectionID connID;
		OSErr err = GetSharedLibrary(INTERFACELIB, kPowerPCCFragArch, kFindCFrag, &connID, NULL, NULL);
		if(err == noErr)
		{
			FindSymbol(connID, "\pNewPtr", &(Ptr)newPtr, NULL);
		}
		else
			SP_CHECK(0);
	}
	
	if(newPtr == 0L)
		return 0L;
	
	return newPtr(count);
}

static void OSFreeMem(void * ptr)
{
	static DisposePtrTypeProc disposePtr = NULL;
	
	if(disposePtr == 0L)
	{
		CFragConnectionID connID;
		OSErr err = GetSharedLibrary(INTERFACELIB, kPowerPCCFragArch, kFindCFrag, &connID, NULL, NULL);
		if(err == noErr)
		{
			FindSymbol(connID, "\pDisposePtr", &(Ptr)disposePtr, NULL);
		}
		else
			SP_CHECK(0);
	}
	
	if(disposePtr == 0L)
		return;
	
	disposePtr((Ptr)ptr);
}

typedef enum
{
	kPtrMalloc,
	kPtrNew,
	kPtrNewPtr
};

#define PTR_SIZE(p) (((const long *)(p))[-1])
#define SET_PTR_SIZE(p,sz) ((((long *)(p))[-1]) = sz)

#if qExtensiveAllocVerif
#define PTR_OFFSET() (4*sizeof(long))
#define PTR_CACHE_SIZE() (5*sizeof(long))
#else
#define PTR_OFFSET() (1*sizeof(long))
#define PTR_CACHE_SIZE() (1*sizeof(long))
#endif

#define ADJUST_SIZE(s) ((s) + PTR_CACHE_SIZE())
#define MIN(a,b) ((a)<(b)?(a):(b))

#if qExtensiveAllocVerif
#define PTR_MAGIC_VALUE() ((long)('mgic'))
#define STORE_MAGIC(p) _putmagic(p)
#define STORE_KIND(p, k) _putkind(p, k)
#define SP_CHECK_MAGIC(p) _checkmagic(p)
#define SP_CHECK_KIND(p, k) _checkkind(p, k)
#define PTR_GARBAGE_PREV(p) (*((void **)(((long *)(p)) - 2)))
#define PTR_PRE_MAGIC(p) ((char *)(((long *)(p)) - 4))
#define PTR_PRE_KIND(p) ((char *)(((long *)(p)) - 3))
#define PTR_POST_MAGIC(p) (((char *)(p)) + PTR_SIZE(p))
#else
#define STORE_MAGIC(p)
#define STORE_KIND(p, k)
#define SP_CHECK_MAGIC(p)
#define SP_CHECK_KIND(p, k)
#endif

#if qExtensiveAllocVerif
static void _putmagic(char *where)
{
	where[0] = 'm';
	where[1] = 'g';
	where[2] = 'i';
	where[3] = 'c';
}

static void _putkind(char *where, int kind)
{
	where[0] = kind;
	where[1] = '\0';
	where[2] = '\0';
	where[3] = '\0';
}

static void _checkmagic(char *where)
{
	SP_CHECK(where[0] == 'm' && where[1] == 'g' && where[2] == 'i' && where[3] == 'c');
}

static void _checkkind(char *where, int kind)
{
	SP_CHECK(where[0] == (char)kind);
}

typedef struct _garbageEntry
{
	struct _garbageEntry *next;
	void *ptr;
} _garbageEntry;

_garbageEntry _garbageRoot = {0L, 0L};
_garbageEntry _garbageFree = {0L, 0L};

extern "C" __declspec(dllexport) void SrDesperateMemCheck(void);

extern "C" __declspec(dllexport) void SrDesperateMemCheck(void)
{
	_garbageEntry *entry = _garbageRoot.next;
	while(entry != 0L)
	{
		SP_CHECK(PTR_SIZE(entry->ptr) >= 0);
		SP_CHECK_MAGIC(PTR_PRE_MAGIC(entry->ptr));
		SP_CHECK_MAGIC(PTR_POST_MAGIC(entry->ptr));
		entry = entry->next;
	}
}

static const size_t SkPreallocateNumEntries = 8192L;

static bool _addtogarbage(void *ptr)
{
	_garbageEntry *entry;
	
	if (_garbageFree.next == 0L)
	{
		entry = (_garbageEntry *)OSAllocateMem(SkPreallocateNumEntries * sizeof(_garbageEntry));

		if (entry == 0L)
		{
			return false;
		}
		for (size_t loop = 0; loop < SkPreallocateNumEntries; ++loop, ++entry)
		{
			entry->next = _garbageFree.next;
			_garbageFree.next = entry;
		}
	}
	
	entry = _garbageFree.next;
	_garbageFree.next = entry->next;
	entry->next = _garbageRoot.next;
	entry->ptr = ptr;
	_garbageRoot.next = entry;
	PTR_GARBAGE_PREV(ptr) = 0L;
	if (entry->next != nil)
	{
		PTR_GARBAGE_PREV(entry->next->ptr) = entry;
	}

	return true;
}

static void _handlegarbage(_garbageEntry *prev, _garbageEntry *entry)
{
	if (prev == 0L)
	{
		_garbageRoot.next = entry->next;
	}
	else
	{
		prev->next = entry->next;
	}
	if (entry->next != 0L)
	{
		PTR_GARBAGE_PREV(entry->next->ptr) = prev;
	}
	entry->next = _garbageFree.next;
	_garbageFree.next = entry->next;
}

static void _removefromgarbage(void *ptr)
{
	_garbageEntry *entry;
	_garbageEntry *prev = (_garbageEntry *) PTR_GARBAGE_PREV(ptr);

	if (prev != 0L && prev->next != nil && prev->next->ptr == ptr)
	{
		_handlegarbage(prev, prev->next);
		return;
	}

	entry = _garbageRoot.next;
	prev = 0L;
	while (entry != 0L)
	{
		if(entry->ptr == ptr)
		{
			_handlegarbage(prev, entry);
			return;
		}
		
		prev = entry;
		entry = entry->next;
	}
	SP_CHECK(0);
		// this guy was not inserted in the collector, why ???
}

#define GARBAGE_STORE(p) _addtogarbage(p)
#define GARBAGE_REMOVE(p) _removefromgarbage(p)
#define GARBAGE_CHECKALL() SrDesperateMemCheck()
#else // !qExtensiveAllocVerif
#define GARBAGE_STORE(p) true
#define GARBAGE_REMOVE(p)
#define GARBAGE_CHECKALL()
#endif //  !qExtensiveAllocVerif

static void *_newptr(size_t count, int kind, bool doclear = false);

static void *_newptr(size_t count, int kind, bool doclear)
{
	SP_CHECK(count >= 0);
	GARBAGE_CHECKALL();

	char * result = (char *) OSAllocateMem(ADJUST_SIZE(count));

	if(result == nil)
		return nil;

	result += PTR_OFFSET();
	
	SET_PTR_SIZE(result, count);

	STORE_KIND(PTR_PRE_KIND(result), kind);
	STORE_MAGIC(PTR_PRE_MAGIC(result));
	STORE_MAGIC(PTR_POST_MAGIC(result));

	if(doclear)
		memset(result, 0, PTR_SIZE(result));

	if (!GARBAGE_STORE(result))
	{
		OSFreeMem(result);
		result = nil;
	}

	return result;
}

static void _freeptr(void *p, int kind)
{
	GARBAGE_CHECKALL();

	SP_CHECK(p != nil);
	if(p == nil)
		return;

	SP_CHECK(PTR_SIZE(p) >= 0);
	SP_CHECK_KIND(PTR_PRE_KIND(p), kind);
	SP_CHECK_MAGIC(PTR_PRE_MAGIC(p));
	SP_CHECK_MAGIC(PTR_POST_MAGIC(p));

	GARBAGE_REMOVE(p);

#if qExtensiveAllocVerif
	memset(p, 7, PTR_SIZE(p));
#endif

	OSFreeMem((char *)p - PTR_OFFSET());
}

static size_t _getptrsize(void *p)
{
	GARBAGE_CHECKALL();

	if(p == nil)
		return 0;
	SP_CHECK(PTR_SIZE(p) >= 0);
	SP_CHECK_MAGIC(PTR_PRE_MAGIC(p));
	SP_CHECK_MAGIC(PTR_POST_MAGIC(p));
	return PTR_SIZE(p);
}

extern "C" void * malloc(size_t size)
{
	return _newptr(size, kPtrMalloc);
}

extern "C" void * calloc(size_t nmemb, size_t size)
{
	return _newptr(nmemb * size, kPtrMalloc, true);
}

extern "C" void free(void *ptr)
{
	_freeptr(ptr, kPtrMalloc);
}

extern "C" void * realloc(void * ptr, size_t size)
{
	void *res;
	res = _newptr(size, kPtrMalloc);
	if(res == 0L)
		return 0L;
	memcpy(res, ptr, MIN(_getptrsize(ptr), size));
	_freeptr(ptr, kPtrMalloc);
	return res;
}

_MSL_IMP_EXP_RUNTIME void *operator new(_CSTD::size_t size) throw(_STD::bad_alloc)
{
	return _newptr(size, kPtrNew);
}

_MSL_IMP_EXP_RUNTIME void *operator new(_CSTD::size_t size, const _STD::nothrow_t&) throw()
{
	return _newptr(size, kPtrNew);
}

_MSL_IMP_EXP_RUNTIME void operator delete(void *ptr) throw()
{
	_freeptr(ptr, kPtrNew);
}

#if __MWERKS__>=0x2020
_MSL_IMP_EXP_RUNTIME extern void *operator new[](_CSTD::size_t size) throw(_STD::bad_alloc)
{
	return operator new(size);
}
_MSL_IMP_EXP_RUNTIME extern void *operator new[](_CSTD::size_t size,const _STD::nothrow_t& nt) throw()
{
	return operator new(size,nt);
}
_MSL_IMP_EXP_RUNTIME extern void operator delete[](void *ptr) throw()
{
	operator delete(ptr);
}
#endif

#if __MWERKS__ >= 0x2400
_MSL_IMP_EXP_RUNTIME extern __declspec(weak) void operator delete(void* ptr,
const _STD::nothrow_t&) _MSL_THROW
{
    operator delete(ptr);
}
_MSL_IMP_EXP_RUNTIME extern __declspec(weak) void
operator delete[](void* ptr, const _STD::nothrow_t&) _MSL_THROW
{
    operator delete(ptr);
}
#endif

pascal __declspec(dllexport) Ptr
NewPtr(Size                   byteCount)
{
	return (Ptr)_newptr(byteCount, kPtrNewPtr);
}

pascal __declspec(dllexport) Ptr
NewPtrClear(Size                   byteCount)
{
	return (Ptr)_newptr(byteCount, kPtrNewPtr, true);
}

pascal __declspec(dllexport) void
DisposePtr(Ptr                    p)
{
	_freeptr(p, kPtrNewPtr);
}

pascal __declspec(dllexport) Size
GetPtrSize                      (Ptr                    p)
{
	return _getptrsize(p);
}

pascal __declspec(dllexport) void
SetPtrSize                      (Ptr                    p,
                                 Size                   newSize)
{
	SP_CHECK(0);
}
#endif
